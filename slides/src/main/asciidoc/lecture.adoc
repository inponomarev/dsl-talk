= One Source to Rule Them All: Kotlin DSLs as a Single Source of Truth for Multiple Tasks 
Ivan Ponomarev
:revealjs_theme: black
:revealjs_customtheme: white_course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:encoding: UTF-8
:lang: ru
include::_doc_general_attributes.adoc[]
:doctype: article
:toclevels: 3
:imagesdir: images
:source-highlighter: highlightjs
:highlightjsdir: highlight
:icons: font
:iconfont-remote!:
:iconfont-name: font-awesome-4.7.0/css/font-awesome
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900
:stem: latexmath

:!figure-caption:

[%notitle]
== Who am I

[cols="30a,70a"]
|===
|image::ivan.jpg[]
|

Ivan Ponomarev

* Staff Engineer @ Synthesized.io
* Teaching Java @ Northeastern University London


|===



== DSLs
Wikipedia:  "*A domain-specific language (DSL)* is a computer language specialized to a particular application domain"

I would say: a language a normal person can create

== DSLs

image::never.jpg[]

== DSLs external and internal

[cols="50a,50a"]
|===
|
[graphviz]
----
digraph G {
graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal;
External->A[style=invis];
External->B[style=invis];
Internal->C[style=invis];
Internal->D[style=invis];
A[label="Designed\nfrom scratch",style="invis"];
B[label="Based\non JSON/YAML/XML", style="invis"];
C[label="Dynamically\ntyped",style=invis];
D[label="Statically\ntyped", style=invis]
}
----
|
|===

== Types of external DSLs

[cols="50a,50a"]
|===
|
[graphviz]
----
digraph G {
graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal[];
External->A[];
External->B[style=invis];
Internal[];
Internal->C[style=invis];
Internal->D[style=invis];
A[label="Designed\nfrom scratch", fillcolor="#ffffcc"];
B[label="Based\non JSON/YAML/XML",style=invis];
C[label="Dynamically\ntyped", style=invis];
D[label="Statically\ntyped", style=invis]
}
----
|
Designed from scratch::
* SQL
* DOT (GraphViz)
* PO (`gettext` localization format)
* HCL (Hashicorp Configuration Language)
* Gherkin (Cucumber framework's language)

|===

== Types of external DSLs

[cols="50a,50a"]
|===
|
[graphviz]
----
digraph G {
graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal[];
External->A[];
External->B[];
Internal[];
Internal->C[style=invis];
Internal->D[style=invis];
A[label="Designed\nfrom scratch"];
B[label="Based\non JSON/YAML/XML", fillcolor="#ffffcc"];
C[label="Dynamically\ntyped", style=invis];
D[label="Statically\ntyped", style=invis]
}
----
|

Based on general purpose markup language::
* **YAML**: OpenAPI, Ansible, GithubActions, k8s definitions...
* **XML**: XSLT, XSD
* **JSON**: Vue i18n files 

|===


== Internal DSLs

[cols="50a,50a"]
|===
|

[graphviz]
----
digraph G {

graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal[];
External->A[];
External->B[];
Internal[];
Internal->C[];
Internal->D[style=invis];
A[label="Designed\nfrom scratch"];
B[label="Based\non JSON/YAML/XML"];
C[label="Dynamically\ntyped", fillcolor="#ffffcc"];
D[label="Statically\ntyped",style=invis];
}
----


|

Subset of a dynamically typed language::

* *Lisp* (historically first): Emacs Lisp, Symbolic Mathematics etc. 
* *Ruby*: Rails, RSpec, Chef...
* *Groovy*: Spock, Ratpack, Grails, Gradle, Jenkinsfile... 
|===


== Internal DSLs

[cols="50a,50a"]
|===
|

[graphviz]
----
digraph G {

graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal[];
External->A[];
External->B[];
Internal[];
Internal->C[];
Internal->D[]
A[label="Designed\nfrom scratch"];
B[label="Based\non JSON/YAML/XML"];
C[label="Dynamically\ntyped"];
D[label="Statically\ntyped", fillcolor="#ffffcc"];
}
----


|

Subset of a statically typed language::

* *Scala*: Scalatest, Akka HTTP...
* **Haskell**: Parsec
* *Kotlin*: Kotlinx.html, Ktor, Gradle,...

|===



== DSL advantages

. Code can *sometimes* be *written* by a subject-matter expert, not programmer
. Code can *often* be *read* by a subject-matter expert
. Code is concise: easy to write/easy to read/easy to support


== DSL disadvantages

. Expensive
.. Requires development on its own
.. Requires IDE support (or all pros will turn into contras)
.. Requires a way to embed DSL into application
. Restrictive

== IDE support 

[cols="50a,50a"]
|===
|

[graphviz]
----
digraph G {

graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal[];
External->A[];
External->B[];
Internal[];
Internal->C[];
Internal->D[]
A[label="Designed\nfrom scratch", fillcolor="#ff6666"];
B[label="Based\non JSON/YAML/XML", fillcolor="#d1c85c"];
C[label="Dynamically\ntyped", fillcolor="#ffb266"];
D[label="Statically\ntyped", fillcolor="#a2d149"];
A->1[style=invis];
B->3[style=invis];
C->2[style=invis];
D->4[style=invis];

1[shape=circle];
2[shape=circle];
3[shape=circle];
4[shape=circle];
}
----
|

1. No support at all
2. Rudimentary support 
3. Partial support (schema-based)
4. Full support

|===

== Restrictions

[cols="50a,50a"]
|===
|

[graphviz]
----
digraph G {

graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal[];
External->A[];
External->B[];
Internal[];
Internal->C[];
Internal->D[]
A[label="Designed\nfrom scratch",fillcolor="#a2d149"];
B[label="Based\non JSON/YAML/XML", fillcolor="#ffb266"];
C[label="Dynamically\ntyped", fillcolor="#d1c85c"];
D[label="Statically\ntyped", fillcolor="#ff6666"];
}
----

|

1. You design it yourself
2. You can be quite flexible
3. You are restricted by markup synthax
4. It's complicated

|===


== Security Concerns

[cols="50a,50a"]
|===
|

[graphviz]
----
digraph G {

graph [ dpi = 180 ];
node[shape="block",style="rounded,filled", fillcolor="#ffffff"]
DSLs;
DSLs->External;
DSLs->Internal[];
External->A[];
External->B[];
Internal[];
Internal->C[];
Internal->D[]
A[label="Designed\nfrom scratch"];
B[label="Based\non JSON/YAML/XML"];
C[label="Dynamically\ntyped"];
D[label="Statically\ntyped"];
}
----

|

1. Is NOT an executable code (which does not mean you're safe, Google for "XML bomb")
2. Executable code

|===

== Kotlin language features for DSL building 

https://www.jmix.io/cuba-blog/kotlin-dsl-from-theory-to-practice/

[cols="1a,1a,1a"]
|===
| Tool	| DSL syntax | General syntax
| Extension functions
| 
[source,kotlin]
----
mylist.first(); 
/* there isn’t first() method
in mylist collection*/
----
| `ListUtlis.first(mylist)`
| Infix functions
| `1 to "one"`
| `1.to("one")`
| Operators overloading
| `collection += element`
| `collection.add(element)`
| Type aliases
| `typealias Point = Pair`
| Creating empty inheritors classes and other duct tapes
| get/set methods convention
|===

== Kotlin language features for DSL building (continued)


[cols="1a,1a,1a"]
|===
| Tool	| DSL syntax | General syntax
| `map["key"] = "value"`
| `map.put("key", "value")`
| Destructuring declaration
| `val (x, y) = Point(0, 0)`
| 
[source,kotlin]
----
val p = Point(0, 0); val x = p.first; 
val y = p.second
----
| Lambda out of parentheses
| `list.forEach { ... }`
| `list.forEach({...})`
| Lambda with receiver
| `Person().apply { name = «John» }`
`@DslMarker`
| N/A
| Context control
| @DslMarker
| N/A
|===

== Demo time!

== Intermediate Conclusions

* One source can be used in 
.. Execution of rules
.. Documentation 
.. Visualization
.. Validation
.. Serialization ("free" JSON/YAML based DSL version for our Kotlin DSL)

== Mixing DSL and code

We can leave extension points in our builder:

[source,kotlin]
----
//In our example
customCondition { Random.nextDouble() < .88} invokes TransformationC


//Or in some other DSL
customBusinessRule { checkSmthProgramatically() }
----

Great for describing business rules (state-transition model, for example), especially if DSL defines only part of rules, which is usually the case.

== Infix functions don't work on `this`

== @DslMarker example

TODO

== KTS example (restrictions?)

TODO

== Conclusions

* DSL combined with designed patterns is a powerful tool for solving multiple tasks

* Creating DSLs in Kotlin is not scary. You can improve parts of your existing internal APIs today making them "DSL-like"

* Internal Kotlin DSLs are not the only way to implement DSLs, but definitely not the worst one in many scenarious.

== Thanks for listening!


icon:envelope[size=lg] ivan@synthesized.io

icon:twitter[size=lg] @inponomarev